\chapter{Decomposition of Edge Labels}
\label{ch:analysis}
%% ==============================

As our goal is to represent general dynamic networks and temporal graphs as EPGs, one problem is the missing periodicity in general temporal and dynamic graphs. 

\begin{figure}[h]
	\begin{minipage}[t]{0.49\textwidth}
		\centering
		\begin{tikzpicture}[every edge quotes/.style = {auto, font=\footnotesize, sloped}]
			\begin{scope}[every node/.style={circle,fill}]
				\node (A) at (0,0) {};
				\node (B) at (0,2) {};
				\node (C) at (2,0) {};
				\node (D) at (2,2) {};
				\node (E) at (1,3) {};
			\end{scope}
			
			\draw (A) edge["101\dots"] (B)
			(B) edge["100\dots"] (C)
			(D) edge["001\dots"] (C)
			(A) edge["000\dots"] (C)
			(D) edge["111\dots"] (E)
			(B) edge["011\dots"] (D)
			(B) edge["101\dots"] (E);
		\end{tikzpicture}\\
		Temporal graph with long labels
	\end{minipage}
	\begin{minipage}[t]{0.49\textwidth}
		\centering
		\begin{tikzpicture}[every edge quotes/.style = {auto, font=\footnotesize, sloped}]
			\begin{scope}[every node/.style={circle,fill}]
				\node (A) at (0,0) {};
				\node (B) at (0,2) {};
				\node (C) at (2,0) {};
				\node (D) at (2,2) {};
				\node (E) at (1,3) {};
			\end{scope}
			
			\draw (A) edge[bend left, below,"101"] (B)
			(A) edge[bend right, below,"0001"] (B)
			(B) edge["100"] (C)
			(D) edge[bend right, below,"0100"] (C)
			(D) edge[bend left, below,"10"] (C)
			(A) edge["0"] (C)
			(D) edge[bend right, above,"110"] (E)
			(B) edge[bend right, below,"01111"] (D)
			(B) edge["10"] (E)
			(E) edge[bend right, below,"01"]  (D);
		\end{tikzpicture}\\
		EPG with multi edges but short labels
	\end{minipage}
	\caption{Desired transformation of temporal graphs into EPGs}
\end{figure}
To transform the long, confusing schedule from the example in Section \ref{ch:Introduction:sec:Motivation} into a periodic and clear schedule, the the temporal graph need to be broken down and transformed into an edge periodic graph.
To transform a temporal graph, for each label a shortest possible string $w'$ which is equal to the original label at every time step $\forall t \geq 0, \tau(e)[t] = w'[t]$ has to be found.
This $w'$ can itself be composed by combining different words $w_1,w_2,\dots,w_n$.
Initially, we start with a temporal graph where all edge labels $\tau(e)$ have fixed length and there are no periods present.
To find and analyze such words in the given labels, the label is interpreted as a \DFA and an algorithm for decomposing \DFAs is adapted to our problem to find smaller \DFAs called factors.
To apply the algorithm which is defined for automata, a label $ w \in \{0,1\}^*$ is interpreted as an unary \DFA.
In the label either the $0s$ or the $1s$ symbols are used to represent final states $F$, see Figure \ref{fig:equivalence-label-dfa}.
The algorithm from \cite{DBLP:journals/corr/abs-2107-04683} which is also described in closer detail in Section \ref{ch:analysis:max-divisors} as well as two novel algorithms are used for decomposing \DFAs.
Due to the fact that we only represent unary automata with \textbf{$|\Sigma| = 1$} and therefore only have a single transition from each state, basically forming a simple circle of all possible states.
This means that for a period length of $i$ we only have to check $i$ states on the circle being in the same state.
Decomposing the obtained \DFA results in a family of smaller \DFAs, with $\cap^k_{i=1} L(\mathcal{A}_i)$ which can be interpreted as a set of binary labels $w_i$ and their bit wise intersection $\land^k_{i=1} w_i$ equals $w'$.
Either the bit wise intersection over all found words is assigned the new label, or each word obtained by interpreting a factor can be its own label, forming an edge periodic multi graph. 

\section{Decomposition of \DFAs and Unary \DFAs}
\label{ch:analysis:decomposition-unary-dfas}

\begin{figure}[h]
	\begin{minipage}[t]{0.29\textwidth}
		\centering
		Label $w=1001$
	\end{minipage}
	\begin{minipage}[t]{0.69\textwidth}
		\centering
		\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
			\node[state,initial,accepting] (q_0)   {$q_0$}; 
			\node[state] (q_1) [right=of q_0] {$q_1$}; 
			\node[state] (q_2) [right=of q_1] {$q_2$}; 
			\node[state,accepting](q_3) [right=of q_2] {$q_3$};
			\path[->] 
			(q_0) edge  node {} (q_1)
			(q_1) edge  node {} (q_2)
			(q_2) edge  node {} (q_3)
			(q_3) edge[bend right, above]  node {} (q_0);
		\end{tikzpicture}
		\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
			\node[state,initial] (q_0)   {$q_0$}; 
			\node[state,accepting] (q_1) [right=of q_0] {$q_1$}; 
			\node[state,accepting] (q_2) [right=of q_1] {$q_2$}; 
			\node[state](q_3) [right=of q_2] {$q_3$};
			\path[->] 
			(q_0) edge  node {} (q_1)
			(q_1) edge  node {} (q_2)
			(q_2) edge  node {} (q_3)
			(q_3) edge[bend right, above]  node {} (q_0);
		\end{tikzpicture}
	\end{minipage}
	\caption{Equivalence of binary strings and unary permutation \DFAs}
	\label{fig:equivalence-label-dfa}
\end{figure}

A \DFA $\mathcal{A}$ is composite if its language $L(\mathcal{A})$ can be decomposed into an intersection $\cap^k_{i=1} L(\mathcal{A}_i)$ of languages of smaller \DFAs. Otherwise, $\mathcal{A}$ is prime.
This notion of \textit{primality} was introduced by Kupferman and Mosheiff in \cite{prime-languages}, and they proved that we can decide whether a \DFA is composite in \ExpSpace and later in \cite{unara-prime-languages}, the decomposition question for unary \DFAs was proven to be in \LogSpace.
In the paper~\cite{DBLP:journals/corr/abs-2107-04683} by Jecker, Mazzocchi and Wolf, they provided a \LogSpace algorithm for commutative permutation \DFAs, if the alphabet size is fixed.
This also puts the bounded $k$-composite question for unary \DFAs in the \LogSpace complexity class, since unary \DFAs are commutative permutation \DFAs by definition.
See Table \ref{tab:dfa-decomp-complexity} for all complexity bounds.
The decomposition of unary \DFAs are usually characterized by means of clean quotients. Let  $A = \lbrace\Sigma, Q, q_I , \sigma, F\rbrace$ be a unary \DFA.
A clean quotient $A_d$ of $A$ is a \DFA obtained by folding its cycle of length $l$ to a cycle of length $d$, for some strict divisor $d$ of $l$. Formally, $A_d$ is induced by the equivalence relation $\sim_d$ defined by:

\[ q_i \sim_d q_j ~\text{if and only if}~i \equiv j ~mod~ d \]

We obtain a \DFA $A_d = \{\Sigma, Q' , [q_I ], \sigma' , F'\}$, where $Q'$ is the set of equivalence classes $[p]$ of the states $p \in Q$, the transition function $\sigma'$ is such that for all $a \in \Sigma$ we have that $\sigma'([p], a) = [\sigma(p, a)]$, and $F'$ is composed of the classes $[p]$ such that there is $q \in F$ such that $p \sim q$. We do not require states related by $\sim$ to agree on membership in $F$, and define $F'$ so that the language of $A_d$ over-approximates that of $A$, $L(A) \subseteq L(A_d)$, as every word accepted by $A$ implies acceptance by $A_d$. 

\begin{figure}[h]
	\begin{minipage}[t]{\textwidth}
		\centering
		\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
			\node[state,initial] (q_0)   {$q_0$}; 
			\node[state,accepting] (q_1) [ right=of q_0] {$q_1$}; 
			\node[state] (q_2) [ right=of q_1] {$q_2$}; 
			\node[state,accepting] (q_3) [ right=of q_2] {$q_3$};
			\node[state](q_4) [ right=of q_3] {$q_4$};
			\node[state](q_5) [ right=of q_4] {$q_5$};
			\path[->] 
			(q_0) edge  node {} (q_1)
			(q_1) edge  node {} (q_2)
			(q_2) edge  node {} (q_3)
			(q_3) edge  node {} (q_4)
			(q_4) edge  node {} (q_5)
			(q_5) edge[bend right, above]  node {} (q_0);
		\end{tikzpicture}		
	\end{minipage}
	\begin{minipage}[b]{0.39\textwidth}
		\centering
		\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
			\node[state,initial] (q_0)   {$q_0$}; 
			\node[state,accepting] (q_1) [right=of q_0] {$q_1$}; 
			\path[->] 
			(q_0) edge  node {} (q_1)
			(q_1) edge[bend right, above]  node {} (q_0);
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}[b]{0.59\textwidth}
		\centering
		\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
			\node[state,initial,accepting] (q_0)   {$q_0$}; 
			\node[state,accepting] (q_1) [right=of q_0] {$q_1$}; 
			\node[state](q_2) [right=of q_1] {$q_2$};
			\path[->] 
			(q_0) edge  node {} (q_1)
			(q_1) edge  node {} (q_2)
			(q_2) edge[bend right, above]  node {} (q_0);
			
		\end{tikzpicture}
	\end{minipage}
	\caption{An example of a \DFA $A$ and its quotients $A_2$ and $A_3$}
	\label{fig:clean-quotients-example}
\end{figure}


In the example in Figure \ref{fig:clean-quotients-example}, the \DFA $A$ with final states $q_1$ and $q_3$ can be replaced by the clean quotients $A_2$ and $A_3$ as there is no $q_i \in Q \backslash F$ in $A$ where both clean quotients $A_d$ are in a final state $q_{i ~mod~ d}$.
We can observe the over-approximation effect in the example depicted in Figure~\ref{fig:clean-quotients-example} as there is a state $q_0$ in $A$ where the clean quotient $A_2$ is in a final state but $A_3$ is not and only the combination of both quotients is a valid decomposition of the original \DFA.
Finding quotients is trivial but the number of potential quotients rises sublinear with the number of states or the length of the edge label.
Given a positive integer $n$, let $d(n)$ denote the number of divisors of $n$ including 1 and $n$, so for example $d(8)=4$.
More generally, if $n$ has a prime factorization $n = p_1^{a_1} \ldots p_k^{a_k}$ then by the fundamental theorem of arithmetic $d(n) = (a_1+1) \cdot \ldots \cdot (a_k+1)$.
Clearly, $d(n) \leq n$ and therefore $d(n) = n^{o(1)}$.
This approach has to evaluate all divisors of $l$, which is not necessary to answer the {\sc{\DFA Decomposition}} question.
By only considering maximal divisors the complexity can be further improved, which will be described in the next chapter.

\section{Decomposition of \DFAs Using Maximal Divisors}
\label{ch:analysis:max-divisors}
The idea of folding \DFAs was greatly improved by Jecker, Mazzocchi and Wolf in \cite{DBLP:journals/corr/abs-2107-04683} by limiting the potential factors to maximal divisors instead of strict divisors of $d$.
This can be done because every factor with length $i_1$ where $i_1$ is not a maximal divisor of $|Q|$, there is a factor with length $i_2$ and an integer $n \in \mathbb{N}$ such that $n \cdot i_1 = i_2$ and the factor with $i_2$ will also cover all the values of the $i_1$ factor.
This property will be useful in another way later in Chapter \ref{chap:novel-algos}, when searching for shorter factors instead of as few factors as possible.

Algorithm 3 from \cite{DBLP:journals/corr/abs-2107-04683}, solves the bounded decomposition problem for an unary \DFA $A$, by iterating over all possible word combinations $2^\mathcal{W}$ from  $\mathcal{W} = \{a^{|Q|/p_i} | 1 \geq i \geq m\}$ and finding a selection of $k$ words from the set, that cover all the rejecting states of $A$.
For each set of binary strings with length of a maximal divisor of $|Q|$ and $\leq k$ ones, the word combination is tested by checking if there are any non final states, not covered by the current set.
Iterating over all states $q \in Q \backslash F$, the function \textit{coverBySet} is called, to find states which are not covered by current set.
In the function, we go through all $k$ words in the set and check if $q$ is covered by the word $a^{|Q|/p_i}$ by calling the \textit{cover} function from Algorithm 2. Here $Q_{q,w_i} = \{\sigma(q,w^\lambda_i)|\lambda \geq |Q|\}$ is generated for the word $a^{|Q|/p_i}$.
If the intersection of $Q_{q,w_i}$ and the final states $F$ of $A$ is empty, $a^{|Q|/p_i}$ covers only rejecting states, and if this is true for all words from the current word combination set, a valid decomposition is found.
The complexity of the given decomposition algorithm is \LogSpace since the prime factor decomposition and the checking of the word combination is in \LogSpace.
The prime factor decomposition of $|Q|$ is in space logarithmic in $|Q|$ since $A$ is given in unary.
As the set of word combinations $\mathcal{W}$ only contains words of length of a maximal divisor of $|Q|$, $|\mathcal{W}|$ is also logarithmic in $|Q|$ and iteration over all sets of $2^\mathcal{W}$ is also possible in \LogSpace, by using a binary string which indicates the characteristic function.

For the decomposition problem for \DFAs this is as good as it gets, but since we actually want to decompose labels, we will focus on the or-decomposition and finding decompositions with different properties than minimal width. We can still evaluate the approach using maximal divisors only as potential factor size while searching for a decomposition of binary labels.
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 