\chapter{Preliminaries}
\label{ch:preliminaries}
%% ==============================

\section{Notation}
\label{ch:prelimiaries:notation}
We denote by $\mathbb{N}$ the set of non-negative integers $\{0, 1, 2, \dots \}$.
We call $d \in \mathbb{N}$ a maximal divisor of an integer $i \in \mathbb{N}$, if $d|i$ and there exists no $c \in \mathbb{N}$ with $c|d$ and $c|i$.

For a word $w = w_1 w_2 \dots w_n$ with $w_i \in \sum$ for $1 \leq i \leq n$, $w[i]$ represents the symbol $w_i$ at position $i$ in $w$ and $\ell(w)$ be the length of $w$.
We write the concatenation of strings $u$ and $v$ as $u \cdot v$.
Moreover, for every $\sigma \in \Sigma$, we denote by $\#\sigma(w)$ the number of times the letter $\sigma$ appears in $w$ and let $w^n$ be the concatenation of $w$ with itself, $n$ times.
The bit wise or operation on binary words is denoted as $\lor$, the bit-wise and operation as $\land$ such that $a = b \vee c$ with, for $1 < i < \max{\ell(b), \ell(c)}$, $a[i] = b[i] \vee c[i]$ if $\min{\ell(b), \ell(c)} > i$ and  $a[i] = b[i]$ (respectively $c[i]$), if $\ell(c) < i$ (respectively $\ell(b) < i$).

\textit{A deterministic finite automaton} (\DFA) is a 5-tuple $A = \lbrace\Sigma, Q, q_I , \sigma, F\rbrace$, where $\Sigma$ is a finite non-empty alphabet, $Q$ is a finite set of states, $\sigma : Q \times \Sigma \rightarrow Q$ is a transition function, $q_I \in Q$ is the initial state, and $F \subseteq Q$ is a set of accepting states.
The states in $Q \backslash F$ are called rejecting states.
The transition function $\sigma$ is expanded to words by defining it recursively $\sigma : Q \times \Sigma^* \rightarrow Q$ is $\sigma(q, \epsilon) = q$ and $\sigma(q, w_1, w_2 \dots w_n ) = \sigma(\sigma(q, w_1 w_2 \dots w_{n-1} ), w_n )$.
The \textit{run} of $A$ on a word $w = w_1 \dots w_n$ is the sequence of states $s_0 , s_1 , \dots , s_n$ such that $s_0 = q_I$ and for each $1 \leq i \leq n$ it holds that $\sigma(s_{i-1} , w_i ) = s_i$.
Note that $s_n = \sigma(q_I , w)$. The \DFA A \textit{accepts} $w$ iff $\sigma(q_I , w) \in F$. Otherwise, $A$ \textit{rejects} $w$.
The set of words accepted by $A$ is denoted $L(A)$ and is called the \textit{language} of $A$.
A language accepted by some \DFA is called a \textit{regular language}.
We refer to the size of a \DFA $A$, denoted $|A|$, as the number of states in $A$.
A \DFA $A$ is \textit{minimal} if every $\DFA~B$ such that $L(B) = L(A)$ satisfies $|B| \geq |A|$.
We call a \DFA a \textit{permutation \DFA} if for each letter $\sigma \in \Sigma$, the transition function is a bijection and we call a \DFA a \textit{commutative \DFA} if $\sigma(q, uv) = \sigma(q, vu)$ for every state $q$ and every pair of words $u, v \in \Sigma^*$.

We call a $\DFA$ $A$ \textit{and-composite} if there exists a family $(B_i)_{1 \leq i \leq k}$ of DFAs with $|B_i| < |A|$ for all $1 \leq i \leq k$, such that $L(A) = \cap_{1\leq i \leq k} L(B_i)$ and call the family $(B_i)_{1\leq i \leq k}$ a \textit{\andDecomp} of $A$.
Note that, all $B_i$ in the decomposition satisfy $|B_i| < |A|$ and $L(A) \subseteq L(B_i)$.
Such DFAs are called \textit{factors} of $A$, and $(B_i)_{1\leq i \leq k}$ is also called a $k$-factor decomposition of $A$.
The width of $A$ is the smallest $k$ for which there is a $k$-factor decomposition of $A$, and we say that $A$ is $k$-factor composite iff $width(A) \leq k$.
We call a DFA $A$ prime if it is not composite.
Similarly, we call $A$ or-composite, if there exists a family $L(A) = \cup_{1\leq i \leq k} L(B'_i)$ of DFAs with $|B'_i| < |A|$ and we call $\cup_{1\leq i \leq k} L(B'_i)$ an \orDecomp of $A$.

When analyzing an \orDecomp $(B_i)_{1 \leq i \leq k}$, a partial \orDecomp up to $j < k$ might have words which are accepted by $A$ but not by $(B_i)_{1 \leq i \leq j}$, those are called \textit{outliers}.
Let $A = (\Sigma, Q, q_I, \sigma, F)$.
We define $out(\{B_1, B_2, \dots, B_j\}) = \{q \in F \mid \forall w \in \Sigma^* \colon \sigma(q_I, w) = q \rightarrow w \notin \bigcup_{1\leq i \leq j} L(B_i)\}$.

An \textit{edge periodic temporal graph} (EPG), $G = (V, E, \tau)$ consists of a graph $G = (V, E)$ called the underlying graph and a function $\tau : E \rightarrow \{0, 1\}^*$ where $\tau$ maps each edge $e$ to a string $\tau(e) \in \{0, 1\}^*$, such that $e$ exists in a time step $t \geq 0$ if and only if $\tau(e)[t] = 1$, where $\tau(e)[t] := \tau(e)[t~ mod~ |\tau(e)|]$.
We denote the subgraph of $G$ in time step $t$ with $G(t)$ and call it the \textit{snapshot graph} at time step $t$.

\section{State of the Art}
\label{ch:prelimiaries:state-of-the-art}
Temporal graphs, also known as time-varying or dynamic graphs, recently gained significant attention.
Various aspects like their representation~\cite{Holme_2012}, analysis~\cite{DBLP:journals/corr/Erlebach0K15}\cite{DBLP:journals/corr/Michail15} as well as mining~\cite{temporal-mining-oettershagen2022tglib} have been explored.
Techniques for community detection, aiming to identify groups of nodes which show cohesive patterns of interactions over time, have been developed by Al-sharoa et al. in~\cite{temporal-comunity-detection-8861143}.
Link prediction techniques have also been explored to predict future edge occurrences based on historical data \cite{temporalLinkPrediction}.
Additionally, various metrics have been proposed to quantify important properties of temporal graphs, such as temporal centrality and clustering coefficients~\cite{temporalClusterCoefficient}.
Understanding the evolution and dynamics of temporal graphs is another research area.
Models have been developed to simulate the evolution of temporal graphs~\cite{temporalEvolution}, considering factors such as edge arrival, departure, and temporal dependencies.
Temporal network analysis involves the development of measures and techniques to characterize and visualize temporal graphs. Visualization techniques have been designed to effectively represent and explore the dynamic nature of temporal graphs~\cite{kerracher2014design}.
Additionaly, temporal graph research finds applications in diverse fields.
For example, it has been applied to study social networks, analyzing the evolution of friendships, communities, and information diffusion~\cite{temporal-friends}\cite{temporal-information-diffusion}.
In transportation systems, temporal graphs help model traffic patterns, optimize routes, and analyze network dynamics~\cite{tang2009temporal}.
In the realm of biology, temporal graphs have been used to study protein-protein interaction networks~\cite{fu2022dppin}, gene regulatory networks, and other biological systems to understand dynamic processes~\cite{dibrita2022temporal}.
Overall, the study of temporal graphs is a multidisciplinary field, with researchers from computer science, biology, physics, and other domains contributing to its advancements.
Ongoing research continues to explore new techniques and methodologies for analyzing, modeling, and understanding the complex dynamics of temporal graphs.

Contrary to the well-established and studied field of temporal graphs, edge periodic graphs have received less attention.
EPG Research has explored areas such as mining periodic cliques \cite{clique-mining-epg}, identifying minors and subgraphs in EPGs \cite{minor-subgraph-epg}, and analyzing EPGs within the context of the Game of Cops and Robbers \cite{erlebach2020game}.
However, the transformation of temporal graphs into EPGs remains an unexplored area.
On the other hand, there are various resources regarding the study of the decomposition of different types of deterministic finite automatons, especially the problem:
\begin{defn}[\sc{\DFA Decomposition}]{\ \\}
	Input: A \DFA $\mathcal{A}$\\
	Question: Is $\mathcal{A}$ and-composite?
\end{defn}
and also the bounded variant of the problem which asks whether a \DFA is $k$-factor composite. While initially the decomposition was proposed for general \DFAs in \cite{prime-languages}, algorithms and complexity bounds for the unbounded decomposition for unary \DFAs were found by Jecker, Kupferman and Mazzocchi~\cite{unara-prime-languages} and for bounded decomposition by Jecker, Mazzocchi and Wolf in \cite{DBLP:journals/corr/abs-2107-04683}.
Further detail about their works in Section \ref{ch:analysis:max-divisors} and in Figure \ref{tab:dfa-decomp-complexity}.
The proofs are formalized for unary \DFAs but they can also be applied to binary labels as transitions are trivial and either 1's or 0's can represent the final states $F$ which will be discussed in Section \ref{ch:analysis:decomposition-unary-dfas}.
\begin{table}[h]
	\centering
	\begin{tabular}{l|rr}
		&  DECOMP & Bounded k-DECOMP  \\
		\hline
		DFA & EXSPACE~\cite{prime-languages} & PSPACE~\cite{DBLP:journals/corr/abs-2107-04683}  \\
		%Permutation DFA&  & NP/FPT\cite{DBLP:journals/corr/abs-2107-04683}  & PSPACE~\cite{DBLP:journals/corr/abs-2107-04683} \\
		%Commutative permutation DFA&  & NL~\cite{DBLP:journals/corr/abs-2107-04683} & NP-complete~\cite{DBLP:journals/corr/abs-2107-04683} \\
		Unary DFA & LOGSPACE~\cite{unara-prime-languages} &  LOGSPACE~\cite{DBLP:journals/corr/abs-2107-04683}
	\end{tabular}
	\caption{Complexity of unbounded and bounded DFA Decomposition}
	\label{tab:dfa-decomp-complexity}
\end{table}


\section{Real World Data (F2F Graphs)}
\label{ch:prelimiaries:real-world-data}
Real world data is helpful in evaluating the effectiveness of the decomposition, therefore a collection of temporal graphs has been gathered from the Stanford Large Network Dataset Collection\footnote{\url{https://snap.stanford.edu/data/}}.
All the temporal graph datasets except one, contain interaction networks of forums such as Stackoverflow or Reddit and are in a format, where the edges have timestamps, at which point in time they are active.
The Reddit network includes timestamps in Unix epoch seconds over a period of 3 years, consequently, the edges are only very rarely present in the graph.
However, it would be possible to reinterpret these, for example, by increasing the time span between discrete time points.
Instead of a time span of 1 second between events, it would also be possible to set the time span to one day, and a label at time point $t$ would contain a 1 if on that day, person $A$ commented on person $B$'s post.
\begin{figure}[b]
	\centering
	\begin{tikzpicture}[every edge quotes/.style = {auto, font=\footnotesize, sloped}]
		\begin{scope}[every node/.style={circle,fill}]
			\node (A) at (0,0) {};
			\node (B) at (0,4) {};
			\node (C) at (4,0) {};
			\node (D) at (4,4) {};
			\node (E) at (2,2) {};
		\end{scope}
		
		 
		\path[->](A) edge["101\dots"] (B);
		\path[->](B) edge["101\dots"] (A);
		\path[->](D) edge["001\dots"] (C);
		\path[->](C) edge["010\dots"] (D);
		\path[->](A) edge["000\dots"] (C);
		\path[->](C) edge["000\dots"] (A);
		\path[->](D) edge[""] (E);
		\path[->](B) edge["011\dots"] (D);
		\path[->](D) edge["011\dots"] (B);
		\path[->](B) edge[""] (E);
		\path[->](A) edge[""] (E);	
		\path[->](C) edge[""] (E);
		\path(B) edge[""] [loop] (B);
		\path(A) edge[""] [loop left] (A);
		\path(C) edge[""] [loop right] (C);	
		\path(D) edge[""] [loop] (D);		
	\end{tikzpicture}
	\caption{Example of the real word input data (F2F Files)}
	\label{tikz:realWorldDataFiles}
\end{figure}
We opted to used the \href{https://snap.stanford.edu/data/comm-f2f-Resistance.html}{Dynamic Face-to-Face Interaction Networks (F2F)} dataset, where the data format is very close to the formal definition, containing binary labels with discrete steps and a one at step $t$ indicating the existence of the respective edge.
These networks represent the interactions that happen during discussions between a group of participants playing a game called Resistance.
This dataset contains networks extracted from 62 games, each game is played by 5-8 participants and lasts between 45-60 minutes.
They extracted dynamically evolving networks from the free-form discussions using the ICAF algorithm~\cite{f2f-bai2019predicting}.
The extracted networks are used to characterize and detect group deceptive behavior using the DeceptionRank algorithm~\cite{f2f-kumar2021deception}.
The networks are unweighted, directed and temporal, each node represents a participant.
At each 1/3 second, a directed edge from node $u$ to $v$ indicates participant $u$ looks at participant $v$ or the laptop.
There are also weighted versions of the networks for other purposes and more of a social analysis but we focus on the unweighted versions as they fit the definition of temporal graphs best.