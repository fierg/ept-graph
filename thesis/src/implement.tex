\chapter{Implementation}
\label{ch:Implementation}
%% ==============================
All algorithms described have been implemented using Kotlin because it can be compiled for the Java Virtual Machine and native execution, therefore it seemed like a good balance between a native implementation and higher language conciseness and fault tolerance.
The project is realized as a maven project, to simplify dependency management.
Although all theoretic results have been performed for \DFAs, since none of the properties of a \DFA is actually used except for the set of final states, the input as well as the factors are represented as boolean arrays, where a 1 indicates a final state.
This benefits performance, as array operations are usually faster than e.g. lists of custom objects and this also enabled easy transformation between labels and boolean arrays and vise versa. 

\section{File Reader}
\label{ch:Implementation:file-reader}
Initially, a network from the F2F set described in Section \ref{ch:prelimiaries:real-world-data} is selected and the file reader parses the desired network id and the number of participants from the \verb*|network_list.csv| file.
With these metadata, the selected dynamic face-to-face interaction network is parsed from the \verb*|network/network[ID].csv|.
Each file has the time series of the who-looks-at-whom networks where each row consists of a timestamp an a binary adjacency matrix.
The binary variables in the adjacency matrix indicate where participant $i$ is looking at in the current timestamp, either one of the other participants or the laptop in front.
As a participant can look at only one direction at a given timestamp, only one of the binary variables is 1 per row.
The file reader parses the adjacency matrix and returns a JGraph object with boolean arrays to represent the edge labels.
For each label then a decomposition is performed, using the specified algorithm.

\section{Decomposition using Maximal Divisors}
\label{ch:Implementation:max-divisor}

For the initial implementation, only maximal divisors were used as this is already well studied.
For an input array of size $n$, all maximal divisors are lazily yielded into a sequence, via a \textit{NumbersExtensions}.
Extension functions are a useful Kotlin tool if you want to extend the static functionality of base classes, e.g. Integers.
Then a preliminary Factor is created for each maximal divisor, with an empty array the size of the divisor, and a job is spawned for each factor as the periodicity of the factors can be tested in parallel.
With the help of Kotlin Co-routines, a modest multi-threading approach is implemented where the main algorithm thread waits for all the factors to be checked. Afterward, they are collected into a \textit{Cover} object, which handles all the validation and quality assessment.
For this, a cover array is created, where all factors are consolidated and uncovered values, so-called outliers, are visible.
As not all inputs are decomposable and by default, we do not allow  $|B_i| = |A|$, we may find labels for which the \DFAs are not decomposable. In this case, we consider them partially decomposable, as the found factors create a cover array that is partially identical to the original but not in all places, so a warning is issued with the number of hard outliers.

\section{Greedy Short Factor Decomposition}
\label{ch:Implementation:greedy-short-factor}
The implementation of the greedy approach to find shorter factors is very similar to the previous method.
As described in Section \ref{ch:novel-algos:greedy-short-factors}, all divisors of the length of the original \DFA are considered instead of just the maximal divisors.
Multi-threading in the job implementation is even more useful as we consider a greater amount of possible factor sizes.
All found factors are again collected into a Cover object, this time we are only adding factors to the cover object if their addition changes the resulting cover array.
In the example from Figure \ref{fig:short-factors} we would only add $A_2$ and skip over $A_4$ since the further addition of factors does not change the resulting decomposition.
If after the addition of a factor a complete decomposition is formed with $L(A) = \cup_{B_i \in \text{Cover}} L(B_i)$ which is validated by counting the outliers and checking for $out(\{B_i \in~\text{Cover}\}) = 0$.
Since is to be expected that a considerable amount of \DFAs generated from labels from real-world data are prime, a decomposition with a given $precision(\{B_i \in~\text{Cover}\})$ is also implemented.

\section{Fourier Transformed Decomposition}
\label{ch:Implementation:fourier-transform}
With the goal of increased explainability, the Fourier-transformed decomposition is implemented according to Section \ref{ch:novel-algos:fourier}.
Similar to the greedy approach, all divisors of the length of the original \DFA are considered.
With the Fourier-transformation of the possible factors, we first remove all multiples of periods as described.
Afterward, the single set value requirement $|F_{B_i}| = 1$ is enforced, by replacing all factors not meeting the requirement, with multiple factors which do hold.
The collecting into a cover is performed greedily again, to reduce the number of factors in the cover to improve explainability.

Independent from the decomposition method used, a \textit{Cover} object can be turned into an EPT multi-graph with the same nodes as the original F2F graph but for each cover, there is now a multi-edge, one for each decomposition with the cover array as the label.

\section{External Libraries}
\label{ch:Implementation:external-libs}
Some external libraries are used throughout this project which was quite simple through the use of maven.
\emph{org.junit.jupiter} provided the packages \emph{junit}, \emph{engine} and \emph{api} in version 4.13.2, which allows a simple test unit creation and execution. Multi-threading was enabled by the use of Kotlin \emph{coroutines} in version 1.7.1, provided by JetBrains.
JGraph \cite{DBLP:journals/corr/abs-1904-08355}, a Java library of graph theory data structures and algorithms, was used in version 1.5.1 for general data structures such as simple and multi-graphs.
Lets-Plot\footnote{\url{https://github.com/JetBrains/lets-plot}} is an open-source plotting library for statistical data was used for analysis, debugging and visualizations used in this document.
A argument parser\footnote{\url{https://github.com/xenomachina/kotlin-argparser}} for Kotlin was used to facilitate the creation of a command line interface.

\section{Usage}
\label{ch:Implementation:usage}
To enable a convenient usage, the algorithm is obtainable as jar file but it can also be built from sources. It provides a simple command line interface

\verb|Usage: EPT Graph Reader options_list|\\
\verb|Arguments: |\\
\verb|input -> input (Network id in range (0..61) { Int }|\\
\verb|threshold [1.0] -> Min threshold of cover to be valid (optional) { Double }|\\
\verb|Options: |\\
\verb|--dotenv, -env [false] -> Use config from .env file|\\
\verb|		(Recommended usage due to amount of args) |\\
\verb|--state, -s [false] -> Invert state to substitute in decomposition|\\
\verb|		(if set, decomposition will replace 0s instead of 1s) |\\
\verb|--Mode of decomposing DFAs [GREEDY_SHORT_FACTORS] -> Choose how|\\
\verb|		a decomposition is found, using only maximal divisors,|\\
\verb|		using all factors and greedily collect up to the threshold|\\
\verb|		or perform a fourier transform for increased understandability.|\\
\verb|		{ Value should be one of [max_divisors, greedy_short_factors,|\\
\verb| 		fourier_transform] }|\\
\verb|--Mode of composing factors [OR] -> Choose how a composition is formed,|\\
\verb|		using AND or OR operator for adding factors together to|\\
\verb|		a decomposition. { Value should be one of [and, or] }|\\
\verb|--skipSelfEdges, -skipSelfEdges [false] -> Skip loop back edges|\\
\verb|		with same source and target, these are often useless. |\\
\verb|--debug, -d [false] -> Turn on debug mode |\\
\verb|--quiet, -q [false] -> Turn on quiet mode |\\
\verb|--deltaWindowPreprocessing [0] -> Delta window|\\
\verb|		 in preprocessing of the label { Int }|\\
\verb|--deltaWindowAlgo [0] -> Delta window during decomposing { Int }|\\
\verb|--help, -h -> Usage info |\\

As it comes with a lot of different modes and parameters, a \verb*|.env| file is also provided, for persisting arguments.
The project is available on Github\footnote{\url{https://github.com/fierg/ept-graph}} and released with an MIT License.