\chapter{Implementation}
\label{ch:Implementation}
%% ==============================
All algorithms described above have been implemented using Kotlin because it can be compiled for the Java Virtual Machine or native execution.
The project is realized as a maven project, to simplify dependency management.
Although all theoretic results have been performed for \DFAs, since none of the properties of a \DFA is actually used except for the set of final states, the input as well as the factors are represented as boolean arrays, where a 1 indicates a final state.
This benefits performance, as array operations are usually faster than e.g. lists of custom objects and this also enabled easy transformation between labels and boolean arrays and vise versa. 

\section{File Reader}
\label{ch:Implementation:file-reader}
Initially, a network from the F2F set described in Section \ref{ch:prelimiaries:real-world-data} is selected and the file reader parses the desired network id and the number of participants from the \verb*|network_list.csv| file.
With these metadata, the selected dynamic face-to-face interaction network is parsed from the \verb*|network/network[ID].csv|.
Each file has the time series of the who-looks-at-whom networks where each row consists of a timestamp and a binary adjacency matrix.
The binary variables in the adjacency matrix indicate where participant $i$ is looking at in the current timestamp, either one of the other participants or the laptop in front.
As a participant can look at only one direction at a given timestamp, only one of the binary variables is 1 per row.
The file reader parses the adjacency matrix and returns a JGraph object with boolean arrays to represent the edge labels.
For each label then a decomposition is performed, using the specified algorithm.

\section{Decomposition using Maximal Divisors}
\label{ch:Implementation:max-divisor}
For the initial implementation, only maximal divisors were used as this is already well studied.
For an input array of size $n$, all maximal divisors are lazily yielded into a sequence, via a \textit{NumbersExtensions}.
Extension functions are a useful Kotlin tools if you want to extend the static functionality of base classes, e.g. Integers.
Then a preliminary Factor is created for each maximal divisor, with an empty array the size of the divisor, and a job is spawned for each factor as the periodicity of the factors can be tested in parallel.
With the help of Kotlin co-routines, a modest multi-threading approach is implemented where the main algorithm thread waits for all the factors to be checked. Afterward, they are collected into a \textit{Cover} object, which handles all the validation and quality assessment.
For this, a cover array is created, where all factors are consolidated and uncovered values, so-called outliers, are visible.
As not all inputs are decomposable and by default, we do not allow  $|B_i| = |A|$, we may find labels for which the \DFAs are not decomposable. In this case, we consider them partially decomposable, as the found factors create a cover array that is partially identical to the original but not in all places, so a warning is issued with the number of hard outliers.

\section{Greedy Short Factor Decomposition}
\label{ch:Implementation:greedy-short-factor}
The implementation of the greedy approach to identify shorter factors closely resembles the previous method.
As explained in Section \ref{ch:novel-algos:greedy-short-factors}, we consider all divisors of the length of the original \DFA instead of just the maximal divisors. Multi-threading in the job implementation becomes even more advantageous when dealing with a larger number of potential factors.
All identified factors are once again gathered into a Cover object.
However, this time, we only include factors in the cover object if their addition alters the resulting cover array.
For instance, in the example illustrated in Figure \ref{fig:short-factors}, we would add $A_2$ and skip over $A_4$ since the further addition of factors doesn't alter the resulting decomposition.
If, following the addition of a factor, a complete decomposition is formed with $L(A) = \cup_{B_i \in \text{Cover}} L(B_i)$, it is then validated by counting the outliers and checking for $out({B_i \in~\text{Cover}}) = 0$.
Given that a substantial number of \DFAs generated from labels in real-world data are likely prime, we've implemented a decomposition with a specified $precision({B_i \in~\text{Cover}})$, as well as a decomposition that allows for potential factors to be as large as the original \DFA size.

\section{Fourier Transformed Decomposition}
\label{ch:Implementation:fourier-transform}
With the goal of increased explainability, the Fourier-transformed decomposition is implemented according to Section \ref{ch:novel-algos:fourier}.
Similar to the the greedy approach, we consider all divisors of the length of the original \DFA.
Employing the Fourier transformation on potential factors involves an additional step where values of a factor $B_i$, that are also covered by a smaller factor $B_j$ with $j|i$, are removed from $B_i$.
Subsequently, we enforce the requirement for a single set value, $|F_{B_i}| = 1$ by replacing factors that fall short of this criterion with multiple factors that each satisfy it and together cover the same values.
The aggregation into a cover is once again executed in a greedy fashion, aiming to minimize the number of factors in the cover for improved clarity.
Regardless of the decomposition method employed, a \textit{Cover} object can be transformed into an EPG multi-graph.
This new graph retains the same nodes as the original F2F graph, but for each cover, there exists a multi-edge, corresponding to each decomposition with the cover array serving as the label.

\section{External Libraries}
\label{ch:Implementation:external-libs}
Some external libraries are used throughout this project which was quite simple through the use of maven.
The library \emph{org.junit.jupiter} provided the packages \emph{junit}, \emph{engine} and \emph{api} in version 4.13.2, which allows a simple test unit creation and execution. Multi-threading was enabled by the use of Kotlin \emph{coroutines} in version 1.7.1, provided by JetBrains.
JGraph \cite{DBLP:journals/corr/abs-1904-08355}, a Java library of graph theory data structures and algorithms, was used in version 1.5.1 for general data structures such as simple and multi-graphs.
Lets-Plot\footnote{\url{https://github.com/JetBrains/lets-plot}} is an open-source plotting library for statistical data and was used for analysis, debugging and visualizations used in this document.
An argument parser\footnote{\url{https://github.com/xenomachina/kotlin-argparser}} for Kotlin was used to facilitate the creation of a command line interface.

\section{Usage}
\label{ch:Implementation:usage}
To enable a convenient usage, the algorithm is obtainable as jar file but it can also be built from sources.
It provides a simple command line interface (CLI) for the EPG generator, providing functionality for generating EPG instances based on the F2F dataset and specified options.
The basic usage involves selecting the temporal network id in the range of 0 to 61 and using the preset default values.

\begin{verbnobox}[\fontsize{10.5pt}{10.5pt}\selectfont]
Usage: EPG Generator options_list
Arguments: 
input -> input (Temporal Network id in range (0..61) { Int }
threshold [1.0] -> Min threshold of cover to be valid (optional) { Double }
Options: 
--dotenv, -env [false] -> Use config from .env file
		(Recommended usage due to amount of args) 
--state, -s [false] -> Invert state to substitute in decomposition
		(if set, decomposition will replace 0s instead of 1s) 
--Mode of decomposing DFAs [GREEDY_SHORT_FACTORS] -> Choose how
		a decomposition is found, using only maximal divisors,
		using all factors and greedily collect up to the threshold
		or perform a fourier transform for increased understandability.
		{ Value should be one of [max_divisors, greedy_short_factors,
 		fourier_transform] }
--Mode of composing factors [OR] -> Choose how a composition is formed,
		using AND or OR operator for adding factors together to
		a decomposition. { Value should be one of [and, or] }
--skipSelfEdges, -skipSelfEdges [false] -> Skip loop back edges
		with same source and target, these are often useless. 
--debug, -d [false] -> Turn on debug mode 
--quiet, -q [false] -> Turn on quiet mode 
--deltaWindowPreprocessing [0] -> Delta window
		 in preprocessing of the label { Int }
--deltaWindowAlgo [0] -> Delta window during decomposing { Int }
--help, -h -> Usage info 
\end{verbnobox}
As it comes with a lot of different modes and parameters, a \verb*|.env| file is also provided, for persisting arguments.
The project is available on Github\footnote{\url{https://github.com/fierg/ept-graph}} and released with an MIT License.
